% ----------------------------------------------------------
% Introdução (exemplo de capítulo sem numeração, mas presente no Sumário)
% ----------------------------------------------------------
\chapter[Introdução]{Introdução}
%\addcontentsline{toc}{chapter}{Introdução}
% ----------------------------------------------------------


Em um mundo cada vez mais interconectado, nós como usuários constantemente exigimos maior disponibilidade de informações através da Web. Essas informações não devem apenas estarem acessíveis, como tamém é crucial que seja rápido o tempo para acessa-lás. Com a expanção da inernet para dispositivos dos mais diversos tipos, tais como \textit{smartphones}, \textit{tables} e dispositivos de \textit{IoT}, questões como tempo de carregamento e consumo de banda vem se tornando fatores cada mais mais debatidos.

O uso de dispositivos móveis para acessar a internet cresceu 63\% somente em 2016. É o que aponta o relatório de Previsão Global de Tráfego de Dados Móveis, elaborada pela Cisco. O tráfego de dados móveis passou de  4.4 exabytes \footnote{Um exabyte é equivalente a um bilhão de gigabytes e mil petabytes.} por mês em 2015, para uma média de 7.2 exabytes mensais em 2016. Esse aumento foi resultado de uma adição de cerca 429 milhões de novos dispositivos móveis a rede, sendo \textit{smartphones} os responsáveis pela maior parte deste crescimento \cite{cisco-network-report}.

Conforme \citeonline{load-time-effects}, usuários tendem a dar mais impotancia à velociade em que recebem a informação do que a estética que ela é apresentada. O tempo de carregamento é um fator decisivo para permanência em uma página Web, uma vez que a maioria dos usuários estão dispostos a aguardar de 6 à 10 segundos antes de abandonar a página. Cada segundo de \textit{delay} pode resultar em uma redução de até 7\% nas taxas de conversão, o que para um \textit{e-commerce} que fatura R\$ 100.000,00 por mês, este segundo pode potencialmente custar R\$ 2.5 milhões em vendas não efetuadas por ano.

Nas últimas décadas, houve uma mudança para um modelo de computação chamado cliente/servidor, que aborda as falhas da computação centralizada. Claramente, o modelo de computação centralizado permanece válido em certos ambientes de negócios, no entanto, apesar de muitos benefícios, a computação centralizada é reconhecida como tendo promovido uma cultura de gerenciamento de informações que não conseguiu atender as necessidades de seus clientes.

Em 2010, ocorreu um grande avanço no número de APIs públicas impulsionado pela transição no modelo de comunicação entre aplicações distribuídas, onde estas passaram a utilizar amplamente o protocolo HTTP e o modelo cliente-servidor para a troca de informações na World Wide Web \cite{tcc-ufsc}. A adoção do REST (REpresentational State Transfer) como o método predominante para construir APIs públicas tem ofuscado qualquer outra tecnologia ou abordagem nos últimos anos. Embora várias alternativas (principalmente SOAP) ainda estejam presentes no mercado, adeptos do modelo SOA para construção de aplicações tomaram uma posição definitiva contra eles e optaram por REST como modelo de comunicação e JSON como seu formato de mensagem \cite{programmableweb-rest-losing}.

Segundo \citeonline{rest-webservice} REST é cada vez mais usado como alternativa ao “já antigo” SOAP em que a principal crítica a este é a burocracia, algo que o REST possui em uma escala muito menor. REST é baseado no \textit{design} do protocolo HTTP, que já possui diversos mecanismos embutidos para representar recursos como código de \textit{status}, representação de tipos de conteúdo, cabeçalhos, etc. O principal nesta arquitetura são as URLs do sistema e os \textit{resources} \footnote{resource é um recurso, entidade}, aproveitando os métodos HTTP para se comunicar.

Foram propostas múltiplas soluções para aumentar a eficiência na busca de dados, alguns em relação aos formatos de consulta e resposta das requisições, enquanto outros estão otimizando o número de solicitações na rede. Uma tendência recente envolve \textit{frameworks} consultas declarativos de dados, onde as aplicações clientes especificam quais dados precisam em um campo por campo base, em vez de buscar tudo a partir de um local específico definido por um URL. Os \textit{frameworks} então otimizaram a comunicação com os servidores para obter os dados de forma eficiente.

Esta é a proposta do GraphQL. Construido pelos desenvolvedores do Facebook para atenter as necessidades internas da rede social em 20121, o GraphQL foi lançado ao público em geral em 2015, e já vem ganhando diversos adeptos. Com a promessa de mitigar alguns problemas crônicos do \textit{design} do REST, como versionamento de APIs, múltiplas viagens de ida e volta e excesso de dados trafegados na rede, a abordagem do Facebook já vem sendo usava por diversas empresas.

REST é de fato, o modelo mais utilizado para comunicação entre cliente e servidor nas aplicações atuais. Este trabalho foca em identificar as diferenças em termos de tempo de carregamento, quantidade de dados trafegados e consumo de recursos entre aplicações REST e o ainda pouco conhecido GraphQL. Ambos as tecnologias são frequentemente usadas e discutidas como soluções para servir dados entre clientes Web e servidores, com cada vez mais desevolvedores se interessando pela nova abordagem GraphQL

