% ---
% primeiro capitulo de Resultados
% ---
\chapter{Resultados}

Neste capítulo, os resultados e a análise dos experimentos realizados durante o trabalho são reportados. Os resultados obtidos nos testes de validação apresentam a média dos valores coletados após diversas execuções dos cenários de forma sequencial.

Foram executadas 30 interações para cada requisição necessária a fim de obeter as respostas das questões levandas no capítulo anterior. Os dados necessários puderam ser buscados em uma única requisição à API GraphQL, enquanto foram precisos à API REST duas requisições para chegar a resposta da primeira questão, e vinte e oito para obter a resposta da segunda. Os detalhes podem ser constatados nas tabelas \ref{tab:request-table1} e \ref{tab:request-table2}.

\begin{table}[htbp]
    \centering
    \begin{tabular}{| l | l | l |}
        \hline
        \textbf{Requisição} & \textbf{Resultado} & \textbf{Número de requisições} \\ \hline
        /pallets & Todos os pallets & 1x \\ \hline
        /items/:id & Detalhes do item mais presente & 1x \\ \hline
    \end{tabular}
    \caption{Fluxo de dados para responder Questão 1} 
    \label{tab:request-table1}
\end{table}

\begin{table}[htbp]
    \centering
    \begin{tabular}{| l | l | l |}
        \hline
        \textbf{Requisição} & \textbf{Resultado} & \textbf{Número de requisições} \\ \hline
        /items & ID do item 22B12 & 1x \\ \hline
        /items/:id & Detalhes do item 22B12 & 1x \\ \hline
        /pallets & Pallets contendo item 22B12 & 1x \\ \hline
        /pallets/:id & Detalhes do Pallet contendo o item 22B12 & 5x \\ \hline
        /addresses/:id & Detalhes do Endereço contendo o item 22B12 & 5x \\ \hline
        /levels/:id & Nível contendo o item 22B12 & 5x \\ \hline
        /slots/:id & Prateleira contendo o item 22B12 & 5x  \\ \hline
        /rows/:id & Linha contendo o item 22B12 & 5x \\ \hline
    \end{tabular}
    \caption{Fluxo de dados para responder Questão 2} 
    \label{tab:request-table2}
\end{table}

Além das 30 interações feitas para cada requisição, foi montado também três cenários para melhor analise dos resultados. Estes cenários possuem quantidade de registros diferentes para as entidades \textup{Item} e \textup{Pallet}, pois são estas que afetam de maneira mais significativa o quão eficiente será a resposta das APIs. Estes três cenários estão descritos na tabela \ref{tab:cenarios} com suas respectivas quantidades.

\begin{table}[htbp]
    \centering
    \begin{tabular}{| l | l | l | l|}
        \hline
        \textbf{Recurso} & \textbf{C1} & \textbf{C2} & \textbf{C3} \\ \hline
        Item & 1000 & 10000 & 30000 \\ \hline
        Pallet & 1000 & 10000 & 30000 \\ \hline
        Address & 156 & 156 & 156 \\ \hline
        Slot & 26 & 26 & 26 \\ \hline
        Row & 2 & 2 & 2 \\ \hline
        Level & 3 & 3 & 3 \\ \hline
    \end{tabular}
    \caption{Cenários analisados} 
    \label{tab:cenarios}
\end{table}

\section{Questão 1}

Embora necessite de buscas mais simples, através da Questão 1 já é possível observar as diferenças em termos de desempenho entre a aplicação REST e a aplicação GraphQL. A Questão 1 busca o Item com a maior quantidade de \textit{pallets} alocados no armazém, e para responde-la é necessário duas etapas. A primeira busca todos os \textit{pallets} registrados no sistema, e após identificado qual o item mais comum presente nos \textit{pallets} registrados, a segunda etapa detalha este item, extraindo a descrição dele por exemplo.

\subsection{Utilização da CPU}

Ao analisarmos a utilização da CPU, ilustrada na figura \ref{fig:q1-cpu}, percebemos que as APIs REST e GraphQL tem desempenho similares nos cenários C1 e C2. Por outro lado, as consultas para o cenário C3, mostram a API REST muito menos eficiente ao utilizar a CPU.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/q1-cpu.png}
    \caption{Comparação da Utilização de CPU}
    \label{fig:q1-cpu}
    \author{fonte: Autor}
\end{figure}

As consultas de C1 exigiram 133.8 ms de CPU na API REST e apenas 111.10 ms na API GraphQL. Executando o cenário C2, a API REST foi processada em 1042.52 ms enquanto a API GraphQL levou 1065.45 ms, e é neste cenário que notamos a maior similaridade no tempo de utilização da CPU entre as APIs. No entanto, quando analisado os resultados de C3, nota-se uma grande desvantagem para API REST, que utilizou 3177.6 ms da CPU enquanto a API GraphQL usou apenas 2382.1 ms uma diferença de cerca de 25\%.
    
\subsection{Consumo de memória}

Os dados do resultado da comparação do consumo de memória expõem que a API REST também se mostrou menos eficiente neste quesito em relação a API GraphQL. Os resultados podem ser obervados na figura \ref{fig:q1-mem}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/q1-memory.png}
    \caption{Comparação do Consumo de Memória}
    \label{fig:q1-mem}
    \author{fonte: Autor}
\end{figure}

Ao compararmos os resultados de C1 e C3, a API REST se mostrou cerca de 15\% menos eficiente que a API GraphQL. O que se destaca é quando comparamos os resultados de C3, em que a API GraphQL consumiu 127.71 megabytes de memória e a API REST consumiu 178.01 megabytes, uma diferença de quase 30\%.

\subsection{Tempo de resposta}

Como esperado, a API implementada com GraphQL realmente respondeu as consultas em um tempo menor do que a API REST. A figura \ref{fig:q1-time} mostra a diferença do tempo de respota das APIs para executar as consultas da primeira questão.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/q1-time.png}
    \caption{Comparação do tempo de resposta}
    \label{fig:q1-time}
    \author{fonte: Autor}
\end{figure}

Nas requisições de C1, a API REST teve como resultado um tempo de resposta de 147.23 ms, enquanto a API GraphQL respondeu a consulta em 115.63 ms, representando uma diferença de 21\% por cento. Ao analizar as consultas de C2, a API REST respondeu as consultas em 1108.13 ms e a API GraphQL devolveu os resultados em 925.63 ms, uma diferença de 16\% por cento. Por último, as consultas de C3 foram respondidas em 2261.1 ms na API REST e 1725.7 ms na API GraphQL, o que representa uma diferença de 23\% por cento.

Para o tempo de respota foi extraido mais um gráfico, que pode ser obersavado na figura \ref{fig:q1-time-line}, que ilustra o tempo que resposta para cada umas das 30 requisições nas duas APIs. Esse gráfico é baseados nas consultas para o cenário C1, e ajuda a explicar o comportamento de tempo resposta de cada uma das APIs.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/q1-time-line.png}
    \caption{Tempo de resposta}
    \label{fig:q1-time-line}
    \author{fonte: Autor}
\end{figure}

É possivel observar em ambos os protótipos que a primeira requisição leva um tempo bem superior que a média do protótipo. Isso se explica pois na primeira requisição a API precisa de um tempo de \textit{warmup}, necessário para estar em pleno desempenho. Esse periodo de \textit{warmup} ocorre apenas a primeira requisição e as próximas requisições já se mostram muito mais rápidas.

\subsection{Tamanho da resposta}

Outro resultado esperado era que o tamanho da resposta da API GraphQL fosse menor do que o tamanho da resposta da API REST. Essa hipótese se confirmou como pode ser visto da figura \ref{fig:q1-size}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/q1-size.png}
    \caption{Comparação do tamanho de resposta}
    \label{fig:q1-size}
    \author{fonte: Autor}
\end{figure}

A API REST respondeu as requisições da Questão 1 com um tamanho de resposta de 174.04 Kb, 1740.17 Kb e 4980 Kb para C1, C2, C3 respectivamente. Da mesma maneira, a API GraphQL teve como resultado respostas com 31.68 Kb, 322.53Kb e 967.35 Kb. Comparando os três cenários é constatado uma diferença constante de cerca de 80\% entre a API REST e a API GraphQL.

%%--------------
%%--------------
%%--------------

\section{Questão 2}

Para as repostas da questão 2, as consultas foram mais complexas na API GraphQL, e mais numerosas na API REST. Estas consultas visaram responder quais são os endereços que contém o Item 22B12, e foi analisando os resultados que é possível identificar a maior diferença de desempenho das APIs, com destaque ao tamanho da resposta obtida.

\subsection{Utilização da CPU}

Analisando os resultados da utilização de CPU, podemos concluir que a API GraphQL utiliza este recurso de uma maneira mais eficiente do que a API REST. A figura \ref{fig:q2-cpu} ilustra os resultados obtidos.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/q2-cpu.png}
    \caption{Comparação da Utilização da CPU - Q2}
    \label{fig:q2-cpu}
    \author{fonte: Autor}
\end{figure}

Aqui a diferença nos resultados obtidos é notada com mais clareza a medida em que aumentamos o número de registros. Analizando C1, a API REST exiigu 244.41 ms da CPU para ser processada, ao mesmo tempo que a API GraphQL exigiu somente 178.22 ms. Nas consultas de C2, a API REST demandou 1787.74 ms para ser processada, e a API GraphQL demandou 1199.53 ms. A maior diferença encontra-se em C3, onde a API REST levou 5383.40 ms para ser completamente processada pela CPU e a API GraphQL levou apenas 3132.98 ms. No cenário C3 observamos uma diferença de mais de 40\% entre o desempenho das APIs.

\subsection{Consumo de memória}

Os dados referentes ao consumo de memória estão ilustrados na figura \ref{fig:q2-mem}, e apontam que a API REST faz uso menos eficiente deste recurso, comparando com o consumo de memória da API GraphQL. Foi analisando esta métrica que se encontrou o único cenário em que a API REST se mostrou mais eficiente que a API GraphQL.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/q2-memory.png}
    \caption{Comparação do Consumo de memória Q2}
    \label{fig:q2-mem}
    \author{fonte: Autor}
\end{figure}

O consumo de memória não se mostrou tão diferente comparando as APIs nos cenários C1 e C2. Nas requisições de C1, a API REST demonstra ser mais eficiente, mesmo que a diferença seja de apenas 9.88 megabytes (ou 12\%), em relação a API GraphQL. A API GraphQL consumiu 76.19 mb de memória, contra 66.27 consumidos pela API REST. Essa melhor eficiencia já não é mais identificada em C2, onde a API REST consumiu 181.02 mb de meória, e a API GraphQL consumiu 26\% mais, totalizando 133.52 mb. Nas consultas de C3, observamos uma diferença relevante no consumo de mémoria, com a API REST consumindo 300.30 mb de memória enquanto a API GraphQL consumiu 206.02, uma impressionante diferença de quase 100 mb ou 30\%.

\subsection{Tempo de resposta}

Como mostra a figura \ref{fig:q2-time}, é possivel identificar com clareza que a API REST leva um tempo consideravelmente maior para responder todas as requisições comparando com o tempo levado pelas consultas na API GraphQL.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/q1-time.png}
    \caption{Comparação do tempo de resposta Q@}
    \label{fig:q2-time}
    \author{fonte: Autor}
\end{figure}

Considerando as consultas de C1, a API REST teve como resultado um tempo de resposta de 254.56 ms, enquanto a API GraphQL respondeu a consulta em 148.5 ms, representando uma diferença de pouco mais de 40\%. Quando analisado as requisições de C2, a API REST respondeu as consultas em 2072.03 ms e a API GraphQL devolveu o resultado em 1201.3 ms, uma diferença de 42\%, muito semelhante ao C1. Por último, as consultas de C3 foram respondidas em 4770.2 ms na API REST e 2291.1 ms na API GraphQL, o que representa uma diferença de pouco mais de 50\%.

Como feito na Questão 1, também foi extraido um gráfigo ilustrando o tempo de resposta para cada umas das 30 requisições, no cenário C1. Entretanto, diferente do que ocorreu na Questão 1, onde grande parte das requisições levaram tempos muito similares, para a Questão 2 obervamos uma diferença muito mais significativa. Os resultados podem ser vistos na \ref{fig:q2-time-line}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/q2-time-line.png}
    \caption{Tempo de resposta}
    \label{fig:q2-time-line}
    \author{fonte: Autor}
\end{figure}

O periodo de \textit{warmup} é também facilmente oberservado na Questão 2. A API REST responde a primeira requisição em quase 500 ms, enquanto a API GraphQL responde a primeira requisição em pouco menos de 400 ms. Essa diferença de quase 100ms se mantém ao decorer das requisições, sendo que a API GraphQL se mostra um pouco mais estável do que a API GraphQL, sem grandes ocilações.

\subsection{Tamanho da resposta}

A API GraphQL também mostrou-se mais vantajosa em termos de tamanho da resposta na Questão 2. A figura \ref{fig:q2-size} mostra a comparação entre os protótipos quando comparados esta métrica.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/q1-size.png}
    \caption{Comparação do tamanho da resposta}
    \label{fig:q2-size}
    \author{fonte: Autor}
\end{figure}

A API REST respondeu as requisições da questão 1 com um tamanho de resposta de 259.53 Kb, 2522.17 Kb e 7221 Kb para C1, C2 e C3 respectivamente. Da mesma maneira, a API GraphQL teve como resultado respostas com 101.73 Kb, 1005.23 Kb e 2850 Kb. Como ocorrido da Questão 1, a diferença de desempenho entre as APIs se manteve em torno de 60\% nos três cenários, deixando claro a melhor eficiencia da API GraphQL neste quesito.